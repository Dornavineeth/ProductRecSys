# -*- coding: utf-8 -*-
"""EDA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D1Sv-ACdq5EyYEWFO_HTu1CoJ1NGNqkr
"""

import time
import numpy as np
import pandas as pd
from collections import defaultdict
from argparse import ArgumentParser
from sklearn.model_selection import train_test_split

# %matplotlib inline
# from surprise import Reader
# from surprise import Dataset
# from surprise import accuracy
# from surprise import KNNWithMeans
from sklearn.preprocessing import LabelEncoder
from sklearn.decomposition import TruncatedSVD
from sklearn.metrics import mean_squared_error



def calculate_precision_recall(test_set, predictions, k):
    precision = 0
    recall = 0
    num_users = 0

    for user_id in test_set['reviewerID_index'].unique():
        actual_products = set(test_set[test_set['reviewerID_index'] == user_id]['productID_index'])
        recommended_products = set()

        for product in actual_products:
            if product in predictions:
                recommended_products.update([pred[0] for pred in predictions[product][:k]])

        true_positives = len(actual_products & recommended_products)
        possible_positives = len(recommended_products)
        relevant_items = len(actual_products)

        if possible_positives > 0:
            precision += true_positives / possible_positives
        if relevant_items > 0:
            recall += true_positives / relevant_items
        num_users += 1

    average_precision = precision / num_users
    average_recall = recall / num_users

    return average_precision, average_recall

def make_recommendations(user_id, data_matrix, correlation_matrix, top_n=10):
    # Get product IDs
    product_ids = list(data_matrix.columns)
    user_idx = list(data_matrix.index).index(user_id)

    # User's correlation with all products
    corr_scores = correlation_matrix[user_idx]

    # Sort and get top N
    sorted_indices = np.argsort(corr_scores)[::-1]
    top_product_indices = sorted_indices[:top_n]
    
    return [product_ids[i] for i in top_product_indices if i != user_idx]

def predict_rating(user_id, product_id, user_data, correlation_matrix, data_matrix):
    try:
        # Map product_id to matrix index
        product_idx = list(data_matrix.columns).index(product_id)

        # Check if user_id exists in user_data
        if user_id in user_data.index:
            # Get user's correlation with the product
            user_correlation = correlation_matrix[product_idx]
            # You might want to transform this correlation score into a rating
            estimated_rating = transform_correlation_to_rating(user_correlation)
            return estimated_rating
        else:
            return 0  # or a suitable default rating
    except ValueError:
        # Product ID not in training set
        return 0  # or a suitable default rating

def generate_predictions(product_id, correlation_matrix, data_matrix):
    if product_id in data_matrix.columns:
        # Map product_id to matrix index
        product_idx = list(data_matrix.columns).index(product_id)
        
        # Get indices of similar products
        similar_products_indices = np.argsort(-correlation_matrix[product_idx])[:10]  # top 10 similar products
        predicted_ratings = []
        for idx in similar_products_indices:
            if idx != product_idx:  # Exclude the same product
                predicted_ratings.append((data_matrix.columns[idx], correlation_matrix[product_idx, idx]))
        return predicted_ratings
    else:
        return []  # Return an empty list if product_id is not in the training set

def generate_test_predictions(test_set, user_data, correlation_matrix, data_matrix):
    predictions = []
    for _, row in test_set.iterrows():
        user_id = row['reviewerID_index']
        product_id = row['productID_index']
        predicted_rating = predict_rating(user_id, product_id, user_data, correlation_matrix, data_matrix)
        predictions.append(predicted_rating)
    return predictions

def parse_args():
    parser = ArgumentParser(description='Recommendation System')
    parser.add_argument('--num_threads', type=str, default='1')
    parser.add_argument('--model_dir', type=str, default='output')
    parser.add_argument('--data_path', type=str, required=True)
    return parser.parse_known_args()[0]

def train(args):
    data_path = args.data_path

    df = pd.read_csv(data_path)
    df.drop(['reviewTime'], axis=1,inplace=True)
    df.drop(['verified'], axis=1,inplace=True)
    # Assuming 'nd' is your pandas dataframe
    le = LabelEncoder()
    for column in df.columns:
        if column != 'rating':
            df[column + '_index'] = le.fit_transform(df[column])

    # Display the transformed DataFrame
    df.drop(['reviewerID'], axis=1,inplace=True)
    df.drop(['productID'], axis=1,inplace=True)
    df = df[['reviewerID_index', 'productID_index','rating']]
    train_df, test_df = train_test_split(df, test_size=0.2, random_state=42)
    # Training data matrix
    train_data_matrix = train_df.pivot_table(values='rating', index='reviewerID_index', columns='productID_index', fill_value=0)

    # Testing data matrix
    test_data_matrix = test_df.pivot_table(values='rating', index='reviewerID_index', columns='productID_index', fill_value=0)
    
    # Apply SVD
    SVD = TruncatedSVD(n_components=3)
    train_matrix_decomposed = SVD.fit_transform(train_data_matrix.T)

    # Prediction using correlation matrix
    correlation_matrix = np.corrcoef(train_matrix_decomposed)
    # Generate predictions for each user in the test set
    # Generating predictions for each product in the test set
    predictions = {}
    for product_id in test_data_matrix.columns:
        if product_id in train_data_matrix.columns:
            predictions[product_id] = generate_predictions(product_id, correlation_matrix, train_data_matrix)

    # Calculate precision, recall, and MSE
    precision, recall = calculate_precision_recall(test_df, predictions, k=10)
    print(f"Precision: {precision}, Recall: {recall}")

    # Generate predictions
    test_predictions = generate_test_predictions(test_df, train_data_matrix, correlation_matrix, train_data_matrix)

    # Actual ratings
    actual_ratings = test_df['rating'].tolist()

    # Calculate RMSE
    mse = mean_squared_error(actual_ratings, test_predictions)
    rmse = np.sqrt(mse)
    print(f"RMSE: {rmse}")

if __name__ == '__main__':
    args = parse_args()
    print(args)
    train(args)




